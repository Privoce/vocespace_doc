import { Tab, Tabs } from "@theme";

# Docker + Nginx

Through this guide, you will learn how to use Docker and Nginx to officially deploy applications to the production environment and configure HTTPS certificates to ensure communication security.

## 1. Copy Basic Configuration

The following is the basic configuration of vocespace. You need to copy this configuration and specify it when starting the container

The defaul "key": `"devkey"`, "secret": `"secret"` works well, however, if you want to improve security and stability, feel free to generate a key/secret pair from your hosted livekit-server.

**[(Optional) How to get key and secret?](./help#how-to-get-key-and-secret)**

```json
{
  "livekit": {
    "key": "devkey",
    "secret": "secret",
    "url": "wss://your.server.name" // modify ⚠️
  },
  "codec": "vp9",
  "resolution": "1080p",
  "maxBitrate": 3000000,
  "maxFramerate": 30,
  "priority": "medium",
  "redis": { 
    "enabled": true, 
    "host": "your.ip", // modify ⚠️
    "port": 6379, 
    "password": "vocespace", 
    "db": 0 
  },
  "server_url": "your.server.name" // modify ⚠️
}
```

> [!WARNING]
>
> `your.ip`: User host machine IP address, you can use `ifconfig | grep inet` to view
> ```bash
> inet 127.0.0.1 netmask 0xff000000
> inet 192.168.31.138 netmask 0xffffff00 broadcast 192.168.31.255
> ```
> In this example `192.168.31.138` is your host machine IP
> 
> `your.server.name`: Domain name for deployment

## 2. Use Docker to deploy applications

### Get VoceSpace Images

VoceSpace contains two images:
- amd: `privoce/vocespace:latest`
- arm: `privoce/vocespace:latest_arm`

So you need to know your current server architecture to make a choice, see: [help-View your own Linux architecture](/doc/deploy/help#check-your-own-linux-architecture)

```shell
# amd
docker pull privoce/vocespace:latest
# arm
docker pull privoce/vocespace:latest_arm
```

### Start Container

Before starting to configure Nginx reverse proxy, we need to run the backend service container first.

```bash
docker run -d \
  -p 3000:3000 \
  -v ${PWD}/vocespace.conf.json:/app/vocespace.conf.json \
  --name vocespace \
  privoce/vocespace:latest
```

> [!NOTE]
>
> * `-p 3000:3000`: Map the container's port 3000 to the host's port 3000.
> * `-v ${PWD}/vocespace.conf.json:/app/vocespace.conf.json`: Map the configuration
> * `--name`: Name the container for easy subsequent management.

## 2. Install and configure Nginx

### 2.1 Install Nginx and Certbot

Make sure the system is updated and install the required packages:

```bash
apt update
apt install nginx certbot python3-certbot-nginx -y
```

> [!WARNING]
>
> * If you are using CentOS or other non-Debian distributions, please change to the corresponding package management command (such as `yum` or `dnf`).
> * `certbot` and `python3-certbot-nginx` are tools for automatically configuring HTTPS.

### 2.2 Configure `nginx.conf` (global configuration, you can ignore here)

Path: `/etc/nginx/nginx.conf`

```nginx
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    include /etc/nginx/conf.d/*.conf;
}
```

> [!NOTE]
>
> * This is a global configuration and usually does not need to be changed frequently.
> * It is recommended to enable logrotate for the log directory to avoid disk fullness.

---

### 2.3 Configure site files (virtual host configuration)

Path recommendation: `/etc/nginx/sites-enabled/vocespace` or `/etc/nginx/conf.d/vocespace`

First, perform a simple configuration:

```nginx
# HTTP to HTTPS redirection
server {
    listen 80;
    listen [::]:80;

    server_name your.server.name; # modify ⚠️

    location / {
        return 301 https://$host$request_uri; # modify ⚠️
    }

    return 404;
}
```
### 2.4 Apply for an HTTPS certificate using Certbot

Make sure the domain name is correctly resolved to the server IP in the DNS service provider.

#### Certificate issuance command

```bash
certbot --nginx -d your.server.name --register-unsafely-without-email
```

> [!NOTE]
>
> * `--nginx`: Certbot will automatically modify your nginx configuration to enable HTTPS.
> * `--register-unsafely-without-email`: Do not bind an email address. **Not recommended for official use**, it is recommended to add `--email your@email.com`.

### Verify Nginx status and restart

```bash
nginx -t
systemctl reload nginx
```

### 2.5 Complete the https configuration

```nginx
# HTTPS reverse proxy configuration
server {
    listen 443 ssl;
    listen [::]:443 ssl;

    server_name your.server.name; # modify ⚠️

    ssl_certificate /etc/letsencrypt/live/your.server.name/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your.server.name/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Application main service (such as front-end or back-end web interface)
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # WebRTC service proxy (port and path depend on the project)
    location /rtc {
        proxy_pass http://127.0.0.1:7880;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
    }

    # Socket.IO real-time communication proxy in nginx here you can ignore
    # location /socket.io {
    #    proxy_pass http://127.0.0.1:3000; 
    #    proxy_http_version 1.1;
    #    proxy_set_header Upgrade $http_upgrade;
    #    proxy_set_header Connection "Upgrade";
    #    proxy_set_header Host $host;
    #    proxy_set_header X-Real-IP $remote_addr;
    #    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #    proxy_set_header X-Forwarded-Proto $scheme;
    #    proxy_cache_bypass $http_upgrade;
    # }
}
```

> [!WARNING]
>
> * `server_name` must be consistent with the domain name of the certificate you actually applied for.
> * Please make sure that the files in `/etc/letsencrypt/live/your.server.name/` have been generated 
> The ssl configuration is generated by certbot

### 2.4 Start and check the status of Nginx

```bash
# Check if the configuration is correct
nginx -t

# Reload the configuration (recommended) or restart the service
systemctl reload nginx
# or
systemctl restart nginx
```
## 3. Start livekit-server

Like local deployment, you also need to start livekit-server to support webrtc. You can choose to download livekit and start it as in local deployment, or you can use docker deployment

<Tabs>
  <Tab label="Local">
    ### Download livekit-server
    
    ```bash
    curl -sSL https://get.livekit.io | bash
    ```
    
   After the download is completed, it will usually be in `/usr/local/bin/livekit-server`

    ### Create configuration
    We provide a minimal configuration to help you deploy quickly. First, create the configuration file `vim /etc/livekit.yml`
    ```yml
    port: 7880
    bind_addresses:
        - "0.0.0.0"
    rtc:
        tcp_port: 7881
        port_range_start: 50000
        port_range_end: 60000
        use_external_ip: true
        enable_loopback_candidate: false
    # optional
    turn:
        enabled: false
        domain: your.turn.domain
        tls_port: 5349
        udp_port: 3478
        external_tls: true
    keys:
      devkey: secret
    ```

    ### Start in the background using nohup

    By using nohup you can start livekit-server in the background and output the logs to `/usr/local/bin/logs/livekit_output.log` for easy viewing
    
    ```bash
    nohup /usr/local/bin/livekit-server --config /etc/livekit.yml > /usr/local/bin/logs/livekit_output.log 2>&1 &
    ```


  </Tab>
  <Tab label="Docker">
  ### docker pull livekit-server
  ```bash
  docker pull livekit/livekit-server:latest
  ```
    ### Create configuration
    We provide a minimal configuration to help you deploy quickly. First, create the configuration file `vim /etc/livekit.yml`
    ```yml
    port: 7880
    bind_addresses:
        - "0.0.0.0"
    rtc:
        tcp_port: 7881
        port_range_start: 50000
        port_range_end: 60000
        use_external_ip: true
        enable_loopback_candidate: false
    turn:
        enabled: false
        domain: turn.vocespace.xyz
        tls_port: 5349
        udp_port: 3478
        external_tls: true
    keys:
      devkey: secret
    ```

    ### Run livekit-server

    Also use the configuration file

    ```bash
    docker run -d \
      --network host \
      --name livekit-server \
      -v /etc/livekit.yml:/etc/livekit.yaml \
      livekit/livekit-server \
      --config /etc/livekit.yaml
    ```
    You can also choose not to use the host method and map ports one by one, but this will take a long time
    ```bash
    docker run -d \
      --name livekit-server \
      -p 7880:7880 \
      -p 50000-60000:50000-60000/udp \
      livekit/livekit-server \
      --config /etc/livekit.yaml
    ```
  </Tab>
</Tabs>

## 4. Download and start Redis

<Tabs>
    <Tab label="Macos">
    ```bash
    brew install redis
    brew services start redis -- --requirepass "vocespace" --bind 0.0.0.0 --protected-mode no
    ```
    </Tab>
    <Tab label="Windows" style={{padding: "6px"}}>
        Click to download [Redis-Windows](https://github.com/tporadowski/redis/releases/download/v5.0.14.1/Redis-x64-5.0.14.1.msi)
        ```bash
        redis-server --requirepass "vocespace" --bind 0.0.0.0 --protected-mode no
        ```
    </Tab>
    <Tab label="Linux">
    ```bash
    apt install redis-server
    redis-server --requirepass "vocespace" --bind 0.0.0.0 --protected-mode no
    systemctl restart redis
    ```
    </Tab>
</Tabs>

## Cloud Server Description

### Configure Security Group/Firewall

When using cloud servers, such as Alibaba Cloud, Tencent Cloud, Google Cloud, etc., you need to configure the security group/firewall of the server.

| port        | type | ingress/egress | allow ip       |
| ----------- | ---- | -------------- | -------------- |
| 3000        | tcp  | ingress        | 0.0.0.0/0 Ipv4 |
| 3000        | tcp  | egress         | 0.0.0.0/0 Ipv4 |
| 7880        | tcp  | ingress        | 0.0.0.0/0 Ipv4 |
| 7881        | tcp  | ingress        | 0.0.0.0/0 Ipv4 |
| 80          | tcp  | ingress        | 0.0.0.0/0 Ipv4 |
| 443         | tcp  | ingress        | 0.0.0.0/0 Ipv4 |
| 50000~60000 | udp  | ingress        | 0.0.0.0/0 Ipv4 |


## Additional suggestions

**Automatically renew the certificate**:

```bash
# Test renewal
certbot renew --dry-run
```

**Open ports in the firewall** (if using `ufw`):

```bash
ufw allow 'Nginx Full'
```

**HTTPS enforcement and security reinforcement**: You can add the following configuration in `nginx.conf`:

  ```nginx
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  ```
